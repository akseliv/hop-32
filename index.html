<script src="/node_modules/phaser-ce/build/phaser.min.js"></script>
<script>
window.onload = function() {
    var game = new Phaser.Game(640, 360, Phaser.CANVAS, 'phaser-example', { preload: preload, create: create, update: update,render: render });
    var player;
    var cursors;
    function preload() {
        game.load.image('player', 'sprites/player.png');
        game.load.image('platform', 'sprites/platform.png');
        game.load.image('TestTiles', 'sprites/test-tiles.png');
        game.load.tilemap('tiles', 'tilemaps/test.json', null, Phaser.Tilemap.TILED_JSON);

    }
    var map;
    var layer;
    var platforms;
    function create() {
        game.time.advancedTiming = true;    
        PIXI.scaleModes.DEFAULT = PIXI.scaleModes.NEAREST;
        map = game.add.tilemap('tiles');
        map.addTilesetImage('redbrick', 'TestTiles');
        map.setCollision(1);
        layer = map.createLayer('Tile Layer 1');
        layer.resizeWorld();

        cursors = game.input.keyboard.createCursorKeys();
        game.physics.startSystem(Phaser.Physics.ARCADE);

        platforms = [];
        platforms[0] = game.add.sprite(128, 320, 'platform');
        game.physics.enable(platforms[0], Phaser.Physics.ARCADE);
        platforms[1] = game.add.sprite(256, 288, 'platform');
        game.physics.enable(platforms[1], Phaser.Physics.ARCADE);

        player = game.add.sprite(32, 288, 'player');
        player.smoothed = false;
        game.physics.enable(player, Phaser.Physics.ARCADE);
        player.body.collideWorldBounds=true;

        platforms.map(function(plat){
            console.log(plat);
        });

    }

    var kcheck = true;
    var heading = {};
    var tween = false;
    var frames = 0;
    var keyDelayFrames = 0;
    var keyDelayFramesCount = -10;
    var frameCount = -10;
    var lastKey = false;
    var lastKeyReleased = false;
    var leapDistance = 32;
    var snapGrid = 32;
    var playerRides = false;
    var deathFlag = false;

    function update() {
        // get dT
        deltaTime = game.time.elapsed/1000;
        // resets
        player.tint = 0xffffff;
        // collisions
        game.physics.arcade.collide(player, layer,function(player, layer){
            frames = 0;
            player.body.velocity.x = 0;
            player.body.velocity.y = 0;
        });

        var playerRideLastFrame = (playerRides) ? true: false;
        playerRides = false;
        var overlaps = [];

        platforms.map(function(plat){
            game.physics.arcade.overlap(player,plat,function(player, platform){
                overlaps.push(platform);
                if(!playerRides && player.body.velocity.x === 0 && player.body.velocity.y === 0 && player.body.x === platform.body.x && player.body.y === platform.body.y){
                    platform.body.velocity.x = 128;
                    playerRides = platform;
                    deathFlag = false;
                    console.log('entered platform');

                }
            });
            game.physics.arcade.collide(plat, layer,function(platform, layer){
                platform.destroy();
            })


        });

        if(!playerRides && deathFlag){
            player.destroy();
        }
        if(playerRideLastFrame && overlaps.length === 0){
            console.log('exited platform');
        }


        if(playerRides){
            player.body.velocity.x = playerRides.body.velocity.x;
            player.body.velocity.y = playerRides.body.velocity.y;
        }
        
        if(frames === 0){

            heading = {};
            snapToGrid();
            frames = false;
            player.body.velocity.x = 0;
            player.body.velocity.y = 0;
            var landingTile = map.getTileWorldXY(player.body.x,player.body.y,32,32,layer);
            if(!landingTile){
                deathFlag = true;
            }
            console.log("x:"+player.body.x,"y:"+player.body.y);
            console.log("landed");

        }

        if(cursors.left.isDown && kcheck){

            heading = {x:-1, y: false}
            kcheck = false;
            frames = frameCount;
            keyDelayFrames = keyDelayFramesCount;
            lastKey = cursors.left;

        } else if (cursors.right.isDown && kcheck){

            heading = {x: 1, y: false}
            kcheck = false;
            frames = frameCount;
            keyDelayFrames = keyDelayFramesCount;
            lastKey = cursors.right;
            console.log("right move");

        } else if (cursors.up.isDown && kcheck){

            heading = {x: false, y: -1}
            kcheck = false;
            frames = frameCount;
            keyDelayFrames = keyDelayFramesCount;
            lastKey = cursors.up;

        } else if (cursors.down.isDown && kcheck){

            heading = {x: false, y: 1}
            kcheck = false;
            frames = frameCount;
            keyDelayFrames = keyDelayFramesCount;
            lastKey = cursors.down;

        }

        if(!frames && keyDelayFrames){
            keyDelayFrames++;
        }
        if((lastKey && keyDelayFrames === 0)){
            keyDelayFrames = false;
            kcheck = true;
        }
        if((lastKey.isUp && frames < -2 && !kcheck)){
            keyDelayFrames = false;
            kcheck = true;
            console.log('timed');
            player.tint = 0xfff333;
        }


        if(typeof heading.x == 'number' && frames < 0){
            var rideVelocity = (playerRides) ? playerRides.body.velocity.x : 0;
            player.body.velocity.x = rideVelocity+((leapDistance)*(60/-frameCount))*60*deltaTime*heading.x;
            frames++;
        }
        if(typeof heading.y == 'number' && frames < 0){
            var rideVelocity = (playerRides) ? playerRides.body.velocity.y : 0;
            player.body.velocity.y = ((leapDistance+rideVelocity)*(60/-frameCount))*60*deltaTime*heading.y;
            frames++;
        }

    }

    function render() {
	    game.debug.text(game.time.fps, 2, 14, "#00ff00");
    }

    function snapToGrid(){
        player.body.position.x = Math.round(player.body.position.x/snapGrid)*snapGrid;
        player.body.position.y = Math.round(player.body.position.y/snapGrid)*snapGrid;
    }

}
</script>
<style>
canvas {
    image-rendering: optimizeSpeed;             /* Older versions of FF          */
    image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
    image-rendering: -webkit-optimize-contrast; /* Safari                        */
    image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
    image-rendering: pixelated;                 /* Awesome future-browsers       */
    -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
}
</style>